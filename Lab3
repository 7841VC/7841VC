#include <stdio.h> //// определение символических констант
	#include<string.h> //Для memset
	int prov(char mass[], int m); // целочисленный тип данных,имя одномерного массива,
	 int main() // точка старта программы
	{
	  int pos,c;
	  int i,F,F1,wlen;
	  char s[50]; // массив символов
	  memset(s,'\0',50); // Заполняем массив символом ‘0’
	  F= wlen=F1=0;  
	  for(i=0; (c=s[i]=getchar())!=EOF; i++) //Чтение символа из стандартного потока ввода.Если достигнут конец файла, то возвращается EOF
	  {
	  	if(c==' '|| c=='.'||c==','||c=='\t'||c=='\n') //'\t' Горизонтальная табуляция,'\n' Переход на новую строку. || Логическое ИЛИ
	  	{
	  		F=0;
	  		if (F==1 && prov(s,i) == 0) //F==1 Равенство,имя одномерного массива, равенство. && Логическое И
				  printf("%d\n",i);
				wlen=i;
	  		i=(-1);
	  		memset(s,'\0',50); //обрабатывает любой буфер памяти как ряд байтов
			break; //окончание работы оператора switch,принудительное окончание цикла, минуя стандартную проверку условия
	  	}
		    else // развилка
		    {
		    	if(F==0){ //Проверяет, равны ли значения двух операндов или нет, если да, то условие становится истинным
		    	F=1;
		    	pos=i;
		               }
			}
		}
	  printf("%d--\n",wlen); //%d Читает десятичное число. --декремент.\n перевод на новую строку
	  for(i=0; (c=s[i]=getchar())!=EOF; i++)
	  {
	  	if(c==' '|| c=='.'||c==','||c=='\t'||c=='\n')
	  	{
	  		
	  		if (F==1 && prov(s,i) == 0 && wlen != i) //! Логическое отрицание, НЕ,
				F1=1;
			printf("%d %d\n", F1,i);
	  		i=(-1);
	  		memset(s,'\0',50);
			F=0;
	  	}
		    else 
		    {
		    	if(F==0)
		    	F=1;
			}
			if (c=='\n') // == Равенство
			break;
		}
	  if (F1==0)
		printf("Words of the same lenght:\n");
	  else
		  printf("Words are not the same lenght\n");
	  getchar();
		return 0; //завершает выполнение функции и возвращает управление вызывающей функции	
	}
	int prov(char s[], int m) 
	{
		int F,i;
		F=0;
		for (i=0; i < m; i++)
		{
			if ((s[i]<'A' || s[i]>'Z') && (s[i]<'a' || s[i]>'z'))
			{
				F=1;
			}
		}
		return F;
	}
